/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 * Specific for the Arduino/AVR
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 *
 * Assumptions: No delays and matrices.
 *              Only discrete models.
 *              Reals on the Arduino are floats (real32)
 *
 * Please contact Controllab (info@controllab.nl)
 * if you need modifications.
 **********************************************************/

/* the header files to include */
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "%SUBMODEL_NAME%.h"

/* extra pre-compiler checks for the assumptions */
#pragma warning (disable:4305)			/* disable warning on assigning double literals to floats */
#pragma warning (disable:4244)			/* disable warning on assigning double literals to floats */

/* the global variables */
const XXDouble %VARPREFIX%start_time = %START_TIME%;
const XXDouble %VARPREFIX%finish_time = %FINISH_TIME%;
const XXDouble %VARPREFIX%step_size = %TIME_STEP_SIZE%;
XXDouble %VARPREFIX%%XX_TIME%;
XXInteger %VARPREFIX%steps;
XXBoolean %VARPREFIX%%XX_INITIALIZE%;
XXBoolean %VARPREFIX%major = XXTRUE;
XXBoolean xx_stop_simulation = XXFALSE;

/* the variable arrays */
%IF%%NUMBER_CONSTANTS%
XXDouble %VARPREFIX%%XX_CONSTANT_ARRAY_NAME%[%NUMBER_CONSTANTS%];		/* constants */
%ENDIF%
%IF%%NUMBER_PARAMETERS%
XXDouble %VARPREFIX%%XX_PARAMETER_ARRAY_NAME%[%NUMBER_PARAMETERS%];		/* parameters */
%ENDIF%
%IF%%NUMBER_INITIAL_VALUES%
XXDouble %VARPREFIX%%XX_INITIAL_VALUE_ARRAY_NAME%[%NUMBER_INITIAL_VALUES%];		/* initial values */
%ENDIF%
%IF%%NUMBER_VARIABLES%
XXDouble %VARPREFIX%%XX_VARIABLE_ARRAY_NAME%[%NUMBER_VARIABLES%];		/* variables */
%ENDIF%
%IF%%NUMBER_STATES%
XXDouble %VARPREFIX%%XX_STATE_ARRAY_NAME%[%NUMBER_STATES%];		/* states */
XXDouble %VARPREFIX%%XX_RATE_ARRAY_NAME%[%NUMBER_STATES%];		/* rates (or new states) */
%ENDIF%
%IF%%NUMBER_MATRICES%
XXMatrix %VARPREFIX%%XX_MATRIX_ARRAY_NAME%[%NUMBER_MATRICES%];		/* matrices */
%ENDIF%
%IF%%NUMBER_UNNAMED%
XXDouble %VARPREFIX%%XX_UNNAMED_ARRAY_NAME%[%NUMBER_UNNAMED%];		/* unnamed */
%ENDIF%
%IF%%WORK_ARRAY_SIZE%
XXDouble %VARPREFIX%workarray[%WORK_ARRAY_SIZE%];
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
XXDouble %VARPREFIX%%XX_FAVORITE_PARS_ARRAY_NAME%[%NUMBER_FAVORITE_PARAMETERS%];	/* favorite parameters */
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
XXDouble %VARPREFIX%%XX_FAVORITE_VARS_ARRAY_NAME%[%NUMBER_FAVORITE_VARIABLES%];		/* favorite variables */
%ENDIF%

/* the names of the variables,  uncomment if you need these ------------------------------- */
%IF%%NUMBER_INPUTS%
/*
const char* %VARPREFIX%input_names[] = {
%INPUT_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_OUTPUTS%
/*
const char* %VARPREFIX%output_names[] = {
%OUTPUT_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_CONSTANTS%
/*
const char* %VARPREFIX%constant_names[] = {
%CONSTANT_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_PARAMETERS%
/*
const char* %VARPREFIX%parameter_names[] = {
%PARAMETER_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_INITIAL_VALUES%
/*
const char* %VARPREFIX%initial_value_names[] = {
%INITIAL_VALUE_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_VARIABLES%
/*
const char* %VARPREFIX%variable_names[] = {
%VARIABLE_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_STATES%
/*
const char* %VARPREFIX%state_names[] = {
%STATE_NAMES%,	NULL
};
const char* %VARPREFIX%rate_names[] = {
%RATE_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_MATRICES%
/*
const char* %VARPREFIX%matrix_names[] = {
%MATRIX_NAMES%,	NULL
};
*/
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
/*
const char* %VARPREFIX%favorite_par_names[] = {
%FAVORITE_PARAMETER_NAMES%, NULL
};
*/
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
/*
const char* %VARPREFIX%favorite_var_names[] = {
%FAVORITE_VARIABLE_NAMES%, NULL
};
*/
%ENDIF%

/* The initialization function for submodel------------------------------------------------------------ */
XXDouble %FUNCTIONPREFIX%InitializeSubmodel (%IF%%NUMBER_INPUTS%
XXDouble *u, %ENDIF%
%IF%%NUMBER_OUTPUTS%
XXDouble *y, %ENDIF%
XXDouble t)
{
	/* 1. prepare initialization phase */
	%VARPREFIX%%XX_INITIALIZE% = XXTRUE;
	%VARPREFIX%%XX_TIME% = %VARPREFIX%start_time;	
	%VARPREFIX%steps = 0;
	
	/* 2. initialize the model; body of %FUNCTIONPREFIX%ModelInitialize (); */
%IF%%NUMBER_CONSTANTS%
	/* 2a. set the constants */
%INITIALIZE_CONSTANTS%
%ENDIF%
%IF%%NUMBER_PARAMETERS%
	/* 2b. set the parameters */
%INITIALIZE_PARAMETERS%
%ENDIF%
%IF%%NUMBER_INITIAL_VALUES%
	/* 2c. set the initial values */
%INITIALIZE_INITIAL_VALUES%
%ENDIF%
%IF%%NUMBER_STATES%
	/* 2d. set the states */
%INITIALIZE_STATES%
%ENDIF%
%IF%%NUMBER_MATRICES%
	/* 2e. set the matrices */
%INITIALIZE_MATRICES%
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
	/* 2f. set the favorite parameters */
%INITIALIZE_FAVORITE_PARS%
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
	/* 2g. set the favorite variables */
%INITIALIZE_FAVORITE_VARS%
%ENDIF%
	/* 3. initialize the integration method */
	%FUNCTIONPREFIX%%INTEGRATION_METHOD_NAME%Initialize();
	
%IF%%NUMBER_INPUTS%
	/* 4. copy the inputs */
	/* %VARPREFIX%%XX_TIME% = t; */
	%FUNCTIONPREFIX%CopyInputsToVariables(u);
%ENDIF%
	/* 5. now calculate the model for the first time */
	/* 5a. calculate the initial equations */
%INITIAL_EQUATIONS%
	/* 5b. calculate the static equations */
	%FUNCTIONPREFIX%CalculateStatic();
	/* 5c. calculate the input equations */
%IF%%NUMBER_FAVORITE_PARAMETERS%
	/* the favorite parameters equations */
%FAVORITE_PARS_EQUATIONS%
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
%FAVORITE_VARS_EQUATIONS%
%ENDIF%
%INPUT_EQUATIONS%
	/* 5d. calculate the dynamic equations */
	%FUNCTIONPREFIX%CalculateDynamic();
	/* 5e. calculate the output equations */
%OUTPUT_EQUATIONS%
%IF%%NUMBEROF_DELAYFUNCTION%	/* 5f. delay update */
	%FUNCTIONPREFIX%DelayUpdate();
%ENDIF%
%IF%%NUMBER_OUTPUTS%
	/* 6. set the outputs */
	%FUNCTIONPREFIX%CopyVariablesToOutputs(y);
%ENDIF%
	/* 7. end of initialization phase */
	%VARPREFIX%%XX_INITIALIZE% = XXFALSE;
		
	/* 8. and return the time */
	return %VARPREFIX%%XX_TIME%;
}

/* The calculation function of the submodel-------------------------------------------------------------- */
%IF%%NUMBER_INPUTS%
/* This function sets the input variables from the input vector */
void %FUNCTIONPREFIX%CopyInputsToVariables (XXDouble *u)
{
	/* Copy the input vector to the input variables */
%INPUT_TO_VARIABLE_EQUATIONS%
}
%ENDIF%
%IF%%NUMBER_OUTPUTS%
/* This function uses the output variables to fill the output vector */
void %FUNCTIONPREFIX%CopyVariablesToOutputs (XXDouble *y)
{
	/* Copy the output variables to the output vector */
%VARIABLE_TO_OUTPUT_EQUATIONS%
}

%ENDIF%
/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void %FUNCTIONPREFIX%CalculateStatic (void)
{
	/* static equations */
%STATIC_EQUATIONS%
}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void %FUNCTIONPREFIX%CalculateDynamic (void)
{
%DYNAMIC_EQUATIONS%

	/* increment the step counter */
	%VARPREFIX%steps++;
}

XXDouble %FUNCTIONPREFIX%CalculateSubmodel(%IF%%NUMBER_INPUTS%
XXDouble *u, %ENDIF%
%IF%%NUMBER_OUTPUTS%
XXDouble *y, %ENDIF%
XXDouble t)
{
	XXInteger index;

	/* %VARPREFIX%%XX_TIME% = t; */
%IF%%NUMBER_INPUTS%
	/* 1. copy the inputs */
	%FUNCTIONPREFIX%CopyInputsToVariables(u);
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
	/* the favorite parameters equations */
%FAVORITE_PARS_EQUATIONS%
%ENDIF%
	/* 2. calculate the input equations */
%INPUT_EQUATIONS%
	/* 3. take a simulation step, body of %FUNCTIONPREFIX%%INTEGRATION_METHOD_NAME%Step () */
	%FUNCTIONPREFIX%%INTEGRATION_METHOD_NAME%Step();
	
	/* 4. calculate the output equations */
%OUTPUT_EQUATIONS%
%IF%%NUMBEROF_DELAYFUNCTION%	/* 4a. delay update */
	%FUNCTIONPREFIX%DelayUpdate();
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
	/* favorite variables */
%FAVORITE_VARS_EQUATIONS%
%ENDIF%
%IF%%NUMBER_OUTPUTS%
	/* 5. set the outputs */
	%FUNCTIONPREFIX%CopyVariablesToOutputs(y);
%ENDIF%
	/* 6. and return the time */
	return %VARPREFIX%%XX_TIME%;
}

/* Terminate-----------------------------------------------------------------------------------------
    most likely never called ? 
*/
XXDouble %FUNCTIONPREFIX%TerminateSubmodel(%IF%%NUMBER_INPUTS%
XXDouble *u, %ENDIF%
%IF%%NUMBER_OUTPUTS%
XXDouble *y, %ENDIF%
XXDouble t)
{
%IF%%NUMBER_OUTPUTS%
	/* 1. copy the inputs */
	/* %VARPREFIX%%XX_TIME% = t; */
%INPUT_TO_VARIABLE_EQUATIONS%
%ENDIF%
	/* 2. calculate the final model equations */
%FINAL_EQUATIONS%
%IF%%NUMBER_OUTPUTS%
	/* 3. set the outputs */
%VARIABLE_TO_OUTPUT_EQUATIONS%
%ENDIF%
	/* 4. and return the time */
	return %VARPREFIX%%XX_TIME%;	
}

%IF%%MODEL_IS_DISCRETE%
#ifdef Discrete_METHOD
/*********************************************************************
 * Discrete integration method
 *********************************************************************/
void %FUNCTIONPREFIX%DiscreteInitialize (void)
{
	%VARPREFIX%major = XXTRUE;
}

/* the termination of the Discrete integration method */
void %FUNCTIONPREFIX%DiscreteTerminate (void)
{
	/* nothing to be done */
}

/* the Discrete integration method itself */
void %FUNCTIONPREFIX%DiscreteStep (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;

	/* for each of the supplied states */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* just a move of the new state */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%%XX_RATE_ARRAY_NAME% [index];
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

	%VARPREFIX%major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
/*********************************************************************/
#endif /* Discrete_METHOD */
%ELSE%
#ifdef Euler_METHOD
/*********************************************************************
 * Euler integration method
 *********************************************************************/
void %FUNCTIONPREFIX%EulerInitialize (void)
{
	/* nothing to be done */
	%VARPREFIX%major = XXTRUE;
}

/* the termination of the Euler integration method */
void %FUNCTIONPREFIX%EulerTerminate (void)
{
	/* nothing to be done */
}

/* the Euler integration method itself */
void %FUNCTIONPREFIX%EulerStep (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;

	/* for each of the supplied states */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* calculate the new state */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%%XX_STATE_ARRAY_NAME% [index] + %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

	%VARPREFIX%major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
/*********************************************************************/
#endif /* Euler_METHOD */

#ifdef RungeKutta2_METHOD
/*********************************************************************
 * RungeKutta2 integration method
 *********************************************************************/
static XXDouble %VARPREFIX%q0[%NUMBER_STATES%];

void %FUNCTIONPREFIX%RungeKutta2Initialize (void)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (%VARPREFIX%q0, 0, %NUMBER_STATES% * sizeof (XXDouble));
%ENDIF%
}

/* the termination of the RungeKutta2 integration method */
void %FUNCTIONPREFIX%RungeKutta2Terminate (void)
{
	/* nothing to be done */
}

/* the Runge-Kutta-2 integration method itself */
void %FUNCTIONPREFIX%RungeKutta2Step (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;

	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate result                                        */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = %VARPREFIX%%XX_TIME%;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (%VARPREFIX%q0, %VARPREFIX%%XX_STATE_ARRAY_NAME%, %NUMBER_STATES% * sizeof (XXDouble));

	/* calculate f (states, t) * 1/2 * dt  =  rates * 1/2 * dt  */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* set the new states to use */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * 0.5 * %VARPREFIX%step_size;
	}

	%VARPREFIX%%XX_TIME% = rktime + 0.5 * %VARPREFIX%step_size;
	%VARPREFIX%major = XXFALSE;
	%FUNCTIONPREFIX%CalculateDynamic ();

	/* for each state */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] +	%VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;
	}
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size;

%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

%ENDIF%
	%VARPREFIX%major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
/*********************************************************************/
#endif /* RungeKutta2_METHOD */

#ifdef RungeKutta4_METHOD
/*********************************************************************
 * RungeKutta4 integration method
 *********************************************************************/
%IF%%NUMBER_STATES%
static XXDouble %VARPREFIX%q0[%NUMBER_STATES%];
static XXDouble %VARPREFIX%q1[%NUMBER_STATES%];
static XXDouble %VARPREFIX%q2[%NUMBER_STATES%];
static XXDouble %VARPREFIX%q3[%NUMBER_STATES%];
static XXDouble %VARPREFIX%q4[%NUMBER_STATES%];

static const XXDouble OneOverSix = 1.0 / 6.0;
%ENDIF%
void %FUNCTIONPREFIX%RungeKutta4Initialize (void)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (%VARPREFIX%q0, 0, %NUMBER_STATES% * sizeof (XXDouble));
	memset (%VARPREFIX%q1, 0, %NUMBER_STATES% * sizeof (XXDouble));
	memset (%VARPREFIX%q2, 0, %NUMBER_STATES% * sizeof (XXDouble));
	memset (%VARPREFIX%q3, 0, %NUMBER_STATES% * sizeof (XXDouble));
	memset (%VARPREFIX%q4, 0, %NUMBER_STATES% * sizeof (XXDouble));
%ENDIF%
}

/* the termination of the RungeKutta4 integration method */
void %FUNCTIONPREFIX%RungeKutta4Terminate (void)
{
	/* nothing yet (our arrays are static) */
}

/* the Runge-Kutta-4 integration method itself */
void %FUNCTIONPREFIX%RungeKutta4Step (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;

	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate state results q1, q2, q3 and q4               */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = %VARPREFIX%%XX_TIME%;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (%VARPREFIX%q0, %VARPREFIX%%XX_STATE_ARRAY_NAME%, %NUMBER_STATES% * sizeof (XXDouble));

	/* calculate q1 = f (states, t) * dt  =  rates * dt  */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* set the intermediate q1 */
		%VARPREFIX%q1 [index] = %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;

		/* set the new states to use  for q2 */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q1 [index] / 2;
	}

	/* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size / 2;

	%VARPREFIX%major = XXFALSE;

	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q2, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %NUMBER_STATES% * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* set the ultimate q2 */
		%VARPREFIX%q2 [index] = %VARPREFIX%q2 [index] * %VARPREFIX%step_size;

		/* set the new states to use */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q2 [index] / 2;
	}

	/* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q3, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %NUMBER_STATES% * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* set the ultimate q3 */
		%VARPREFIX%q3 [index] = %VARPREFIX%q3 [index] * %VARPREFIX%step_size;

		/* set the new states */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q3 [index];
	}

	/* calculate q4 = f (states + q3, t + dt) * dt */
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size;
	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q4, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %NUMBER_STATES% * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %NUMBER_STATES%; index++)
	{
		/* set the ultimate q4 */
		%VARPREFIX%q4 [index] = %VARPREFIX%q4 [index] * %VARPREFIX%step_size;

		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		%VARPREFIX%%XX_STATE_ARRAY_NAME%[index] = %VARPREFIX%q0[index] + (%VARPREFIX%q1[index] + %VARPREFIX%q2[index] + %VARPREFIX%q2[index] + %VARPREFIX%q3[index] + %VARPREFIX%q3[index] + %VARPREFIX%q4[index]) * OneOverSix;
	}
%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;
%ENDIF%

	%VARPREFIX%major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
#endif /* RungeKutta4_METHOD */
%ENDIF%

/* Support functions that are part of 20-sim but not part of ANSI-C ------------------------------------
*/
/* Constants that are used in our functions below */
%IF%%OR(NUMBEROF_LOG2FUNCTION, NUMBEROF_EXP2FUNCTION)%
XXDouble xx_logarithm_2 =  0.6931471805599;
%ENDIF%
%IF%%OR(NUMBEROF_LOG10FUNCTION, NUMBEROF_EXP10FUNCTION)%
XXDouble xx_logarithm_10 = 2.3025850929940;
%ENDIF%

/* The 20-sim SIDOPS support functions */
%IF%%NUMBEROF_ABSFUNCTION%
XXDouble XXAbsolute (XXDouble argument)
{
	return (XXDouble) fabs (argument);
}
%ENDIF%
%IF%%NUMBEROF_ARCCOSHYPERBOLICFUNCTION%
XXDouble XXArcCosineHyperbolic (XXDouble argument)
{
	return (XXDouble) log (argument + sqrt(argument * argument - 1.0));
}
%ENDIF%
%IF%%NUMBEROF_ARCSINHYPERBOLICFUNCTION%
XXDouble XXArcSineHyperbolic (XXDouble argument)
{
	return (XXDouble) log (argument + sqrt(argument * argument + 1.0));
}
%ENDIF%
%IF%%NUMBEROF_ARCTANHYPERBOLICFUNCTION%
XXDouble XXArcTangentHyperbolic (XXDouble argument)
{
	return (XXDouble) 0.5 * log ((1.0 + argument) / (1.0 - argument));;
}
%ENDIF%
%IF%%NUMBEROF_EXP2FUNCTION%
XXDouble XXExponent2 (XXDouble argument)
{
	return (XXDouble) exp (argument * xx_logarithm_2);
}
%ENDIF%
%IF%%NUMBEROF_EXP10FUNCTION%
XXDouble XXExponent10 (XXDouble argument)
{
	return (XXDouble) exp (argument * xx_logarithm_10);
}
%ENDIF%
%IF%%NUMBEROF_DIVISION%
XXDouble XXIntegerDivide (XXDouble argument1, XXDouble argument2)
{
	XXInteger value;

	value = (XXInteger) (argument1 / argument2);
	return (XXDouble) value;
}
%ENDIF%
%IF%%NUMBEROF_MODULO%
XXDouble XXIntegerModulo (XXDouble argument1, XXDouble argument2)
{
	XXInteger value;

	value = (XXInteger) (argument1 / argument2);
	return (XXDouble) argument1 - (value * argument2);
}
%ENDIF%
%IF%%NUMBEROF_LOG2FUNCTION%
XXDouble XXLogarithm2 (XXDouble argument)
{
	return (XXDouble) log (argument) / xx_logarithm_2;
}
%ENDIF%
%IF%%NUMBEROF_LOG10FUNCTION%
XXDouble XXLogarithm10 (XXDouble argument)
{
	return (XXDouble) log (argument) / xx_logarithm_10;
}
%ENDIF%

%IF%%NUMBEROF_POWER%
XXDouble XXPow2 (XXDouble argument)
{
	return argument * argument;
}

XXDouble XXPower (XXDouble argument1, XXDouble argument2)
{
	return (XXDouble) pow (argument1, argument2);
}
%ENDIF%
%IF%%OR(NUMBEROF_GAUSSFUNCTION,NUMBEROF_RANDOMFUNCTION)%
XXDouble XXRandom (XXDouble argument)
{
	XXDouble value;

	value = (XXDouble) rand() / (XXDouble) RAND_MAX - 0.5;
	return argument * 2.0 * value;
}
%ENDIF%
%IF%%NUMBEROF_RAMPFUNCTION%
XXDouble XXRamp (XXDouble argument, XXDouble time)
{
	XXDouble value;

	if (time < argument)
		value = 0.0;
	else
		value = time - argument;
	return value;
}
%ENDIF%
%IF%%NUMBEROF_ROUNDFUNCTION%
XXDouble XXRound (XXDouble argument)
{
	XXDouble leftOver, result;

	leftOver = argument - (XXInteger) argument;
	if (fabs (leftOver) < 0.5)
	{
		result = (XXDouble) ((XXInteger) argument);
	}
	else
	{
		if (argument >= 0)
			result = (XXDouble) ceil (argument);
		else
		{
			result = (XXDouble) floor (argument);
		}
	}
	return result;
}
%ENDIF%
%IF%%NUMBEROF_SIGNFUNCTION%
XXDouble XXSign (XXDouble argument)
{
	XXDouble value;
	if (argument < 0.0)
		value = -1.0;
	else
		if (argument == 0.0)
			value = 0.0;
		else
			value = 1.0;
	return value;
}
%ENDIF%
%IF%%NUMBEROF_STEPFUNCTION%
XXDouble XXStep (XXDouble argument, XXDouble time)
{
	XXDouble value;

	if (time < argument)
		value = 0.0;
	else
		value = 1.0;
	return value;
}
%ENDIF%
%IF%%NUMBEROF_IMPULSEFUNCTION%
XXDouble XXImpulse (XXDouble impulsestarttime, XXDouble impulseduration, XXDouble currenttime, XXDouble stepsize)
{
	XXDouble value;

	if (stepsize <= 0.0 || impulseduration <= 0.0)
		value = 0.0;
	else
	{
		if ((currenttime < impulsestarttime) || (currenttime > (impulsestarttime + impulseduration)))
			value = 0.0;
		else
		{
			if (stepsize < impulseduration)
				value = (1.0 / impulseduration);
			else
				value = (1.0 / stepsize);
		}
	}
	return value;
}
%ENDIF%
%IF%%NUMBEROF_XOR%
XXDouble XXXor(XXDouble argument1, XXDouble argument2)
{
	return (argument1 || argument2) && !(argument1 && argument2);
}
%ENDIF%

%IF%%NUMBEROF_DELAYFUNCTION%
XXDouble %VARPREFIX%delay_update_array[%NUMBEROF_DELAYFUNCTION%];
XXDouble %VARPREFIX%delay_last_values[%NUMBEROF_DELAYFUNCTION%];
void %FUNCTIONPREFIX%DelayUpdate()
{
	memcpy(%VARPREFIX%delay_update_array, %VARPREFIX%delay_last_values, %NUMBEROF_DELAYFUNCTION% * sizeof(XXDouble));
}
XXDouble XXDelay (XXDouble argument1, XXDouble argument2, XXInteger id)
{
	XXDouble value;

	if (%VARPREFIX%%XX_INITIALIZE%)
	{
		value = argument2;
	}
	else
	{
		value = %VARPREFIX%delay_update_array[id];
	}

	if (%VARPREFIX%major)
	{
		%VARPREFIX%delay_last_values[id] = argument1;
	}

	return value;
}
%ENDIF%

%IF%%NUMBEROF_INITIALFUNCTION%
XXDouble %VARPREFIX%initial_value_array[%NUMBEROF_INITIALFUNCTION%];

XXDouble XXInitialValue (XXDouble argument, XXInteger identifier)
{
	XXDouble value;

	if (%VARPREFIX%%XX_INITIALIZE%)
	{
		value = argument;
		%VARPREFIX%initial_value_array[identifier] = value;
	}
	else
	{
		value = %VARPREFIX%initial_value_array[identifier];
	}
	return value;
}
%ENDIF%
%IF%%NUMBEROF_BITAND%
XXInteger XXBitAnd(XXInteger argument1, XXInteger argument2)
{
	/* bitwise and */
	return (argument1 & argument2);
}
%ENDIF%
%IF%%NUMBEROF_BITOR%
XXInteger XXBitOr(XXInteger argument1, XXInteger argument2)
{
	/* bitwise or */
	return  (argument1 | argument2);
}
%ENDIF%
%IF%%NUMBEROF_BITXOR%
XXInteger XXBitXor(XXInteger argument1, XXInteger argument2)
{
	/* bitwise xor */
	return (argument1 ^ argument2);
}
%ENDIF%
%IF%%NUMBEROF_BITCMP%
XXInteger XXBitCmp(XXInteger argument, XXInteger nrBits)
{
	XXInteger bits = (XXInteger)(pow(2.0, (double)nrBits)) - 1;

	/* only do the last number of asked bits (the and operator) and invert */
	return (bits - argument);
}
%ENDIF%
%IF%%NUMBEROF_BITGET%
XXInteger XXBitGet(XXInteger argument, XXInteger bitPos)
{
	return (argument & (1 << (bitPos - 1)));
}
%ENDIF%
%IF%%NUMBEROF_BITSET%
XXInteger XXBitSet(XXInteger argument, XXInteger bitPos)
{
	/* Set the bit to 1 */
	return (argument | (1 << (bitPos - 1)));
}
%ENDIF%
%IF%%NUMBEROF_BITCLEAR%
XXInteger XXBitClear(XXInteger argument, XXInteger bitPos)
{
	/* Clear the bit */
	return (argument & ~(1 << (bitPos - 1)));
}
%ENDIF%
%IF%%NUMBEROF_BITSHIFT%
XXInteger XXBitShift(XXInteger argument, XXInteger bitsToShift)
{
	if ( bitsToShift > 0 )
	{
		return (argument << bitsToShift);
	}
	else
	{
		return (argument >> (-bitsToShift));
	}
}
%ENDIF%
%IF%%NUMBEROF_BITSWAPBYTES%
XXInteger XXSwapBytes(XXInteger argument)
{
	int arg1;
	int byte1;
	int byte2;
	int byte3;
	int byte4;
	int result;
	
	arg1 = (int) argument;	/* the argument to swap (only 32-bits swap) */

	byte1 =  0x000000ff & arg1;
	byte2 = (0x0000ff00 & arg1) >> 8;
	byte3 = (0x00ff0000 & arg1) >> 16;
	byte4 = (0xff000000 & arg1) >> 24;

	/* do the explicit 32-bit swap */
	result = (byte1 << 24) + (byte2 << 16) + (byte3 << 8) + byte4;

	return (XXInteger) result;
}
%ENDIF%
/* 20-sim stubs. Implement them yourself if needed */
%IF%%NUMBEROF_DATAFUNCTION%
XXDouble XXData (XXString name, XXInteger column, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_TABLEFUNCTION%
XXDouble XXTable (XXString name, XXDouble argument, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_EVENTFUNCTION%
XXBoolean XXEvent (XXDouble argument, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_EVENTUPFUNCTION%
XXBoolean XXEventUp (XXDouble argument, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_EVENTDOWNFUNCTION%
XXBoolean XXEventDown (XXDouble argument, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_FREQUENCYEVENTFUNCTION%
XXBoolean XXFrequencyEvent (XXDouble argument, XXInteger id)
{
	return 0;
}

XXBoolean XXFrequencyEvent1 (XXDouble argument1, XXDouble argument2, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_TIMEEVENTFUNCTION%
XXBoolean XXTimeEvent (XXDouble argument, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_TDELAYFUNCTION%
XXDouble XXTimeDelay (XXDouble argument, XXDouble time, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_WARNSTATEMENT%
XXBoolean XXWarning (XXString message, XXInteger id)
{
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_STOPSTATEMENT%
XXBoolean XXStopSimulation (XXString message, XXInteger id)
{
	%VARPREFIX%stop_simulation = XXTRUE;
	return 0;
}
%ENDIF%
%IF%%NUMBEROF_REALTIME%
XXDouble XXRealTime(void)
{
	/* TODO: Return the elapsed amount of seconds since the start of this program (preferably with millisecond accuracy) */
	return 0.0;
}

%ENDIF%

%IF%%NUMBER_MATRICES%
/* Matrix support functions */
/* copy a matrix source to a matrix destination
*/
void XXMatrixMov (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	/* use a while loop because it is efficient! */
	XXInteger size;

	size = mat_dest->rows * mat_dest->columns;
	memcpy(mat_dest->mat, mat_source->mat, size * sizeof(XXDouble));
}


/* copy a scalar to every element in a matrix destination
*/
void XXMatrixScalarMov (XXMatrix *mat_dest, XXDouble s)
{
	XXDouble *d;
	XXInteger i;

	d = mat_dest->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s;
		d++;
		i--;
	}
}


/* get the row(zero_based) designated by the integer
   from the source to the destination. destination is vector
*/
void XXMatrixGetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
{
	XXInteger size;

	size = mat_source->columns;

	/* do it with a memcpy, since it is linear memory */
	memcpy(mat_dest->mat, &mat_source->mat[size*row], size * sizeof(XXDouble));
}


/* set the row(zero_based) designated by the integer
   to the destination from the source. source is vector
*/
void XXMatrixSetRow (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger row)
{
	XXInteger size;

	size = mat_source->columns;

	/* do it with a memcpy, since it is linear memory */
	memcpy(&mat_dest->mat[size*row], mat_source->mat, size * sizeof(XXDouble));
}


/* get the column(zero_based) designated by the integer
   from the source to the destination. destination is vector
*/
void XXMatrixGetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
{
	XXInteger i, rows, columns;

	rows = mat_source->rows;
	columns = mat_source->columns;

	for( i = 0; i < rows; i++)
		mat_dest->mat[i] = mat_source->mat[columns * i + column];
}


/* set the column(zero_based) designated by the integer
   to the destination from the source. source is vector
*/
void XXMatrixSetColumn (XXMatrix *mat_dest, XXMatrix *mat_source, XXInteger column)
{
	XXInteger i, rows, columns;

	rows = mat_dest->rows;
	columns = mat_dest->columns;

	for( i = 0; i < rows; i++)
		mat_dest->mat[columns * i + column] = mat_source->mat[i];
}

%IF%%NUMBEROF_DIAGFUNCTION%
/* use the source vector as elements of the diagonal in the
   destination matrix
*/
void XXMatrixDiag (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXInteger i, size;

	size = mat_dest->rows;

	/* first everything zero */
	memset(mat_dest->mat, 0, size * size * sizeof(XXDouble));

	/* and loop to set the diagonal values */
	for( i = 0; i < size; i++)
	{
		/* set the diagonal value */
		mat_dest->mat[size*i+i] = mat_source->mat[i];
	}
}
%ENDIF%

/* add a matrix source1 to a matrix source2 to a matrix destination
*/
void XXMatrixAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s1;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) + (*s2);
		d++;s1++;s2++;
		i--;
	}
}


/* add a matrix source1 to a scalar source2 to a matrix destination
*/
void XXMatrixScalarAdd (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d;
	XXDouble *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) + s2;
		d++;s1++;
		i--;
	}
}


/* add a scalar source1 to a matrix source2 to a matrix destination
*/
void XXScalarMatrixAdd (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s1 + (*s2);
		d++;s2++;
		i--;
	}
}


/* add a scalar source1 to a scalar source2 to a matrix destination
*/
void XXScalarScalarAdd (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 + s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* subtract a matrix source2 from a matrix source1 to a matrix destination
*/
void XXMatrixSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s1;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) - (*s2);
		d++;s1++;s2++;
		i--;
	}
}


/* subtract a scalar source2 from a matrix source1 to a matrix destination
*/
void XXMatrixScalarSub (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d;
	XXDouble *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = (*s1) - s2;
		d++;s1++;
		i--;
	}
}


/* subtract a matrix source2 from a scalar source1 to a matrix destination
*/
void XXScalarMatrixSub (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d;
	XXDouble *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;

	/* use a while loop because it is efficient! */
	i = mat_dest->rows * mat_dest->columns;
	while(i)
	{
		(*d) = s1 - (*s2);
		d++;s2++;
		i--;
	}
}


/* subtract a scalar source2 from a scalar source1 to a matrix destination
*/
void XXScalarScalarSub (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 - s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* multiply matrix source1 and matrix source2 to destination matrix
*/
void XXMatrixMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	/* do the actual multiplication (code needs no documentation, obviously) */
	XXInteger destIndex1, destIndex2, s1Index;
	XXDouble *d, *s1, *s2;
	XXDouble *d2, *s11, *s22;
	XXInteger i, j, k;
	XXInteger cMatSource1m;
	//XXInteger cMatSource1n
	XXInteger cMatSource2m;
	XXInteger cMatSource2n;
	XXInteger cMatDestn, cMatDestm;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;
	cMatSource1m = mat_source1->columns;
	//cMatSource1n = mat_source1->rows;
	cMatSource2m = mat_source2->columns;
	cMatSource2n = mat_source2->rows;
	cMatDestn = mat_dest->rows;
	cMatDestm = mat_dest->columns;

	i = 0;

	while (i < cMatDestn)
	{
		destIndex1 = cMatDestm * i;
		s1Index = i * cMatSource1m;

		j = 0;
		while (j < cMatDestm)
		{
			destIndex2 = destIndex1+j;
			d2 = d + destIndex2;
			*d2 = 0.0;
			s11 = s1 + s1Index;
			s22 = s2 + j;
			k = cMatSource2n;
			while (k)
			{
				(*d2) += (*s11) * (*s22);
				s11++;
				k--;
				s22 += cMatSource2m;
			}
			j++;
		}
		i++;
	}
}


/* multiply matrix source1 with scalar source2 to matrix destination
*/
void XXMatrixScalarMul (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d, *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = (*s1) * s2;
		d++; s1++; i--;
	}
}


/* multiply scalar source1 with matrix source2 to matrix destination
*/
void XXScalarMatrixMul (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2)
{
	XXDouble *d, *s2;
	XXInteger i;

	d = mat_dest->mat;
	s2 = mat_source2->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = s1 * (*s2);
		d++; s2++; i--;
	}
}


/* multiply scalar source1 with scalar source2 to matrix destination
*/
void XXScalarScalarMul (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 * s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* multiply matrix source1 with matrix source2 to scalar destination
   the sizes are not checked but it should be that rows of source1 == 1 and columns source2 == 1
*/
void XXScalarMatrixMatrixMul (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i, size;

	*dest = 0.0;
	size = mat_source1->columns;
	for(i = 0; i < size; i++)
		*dest += mat_source1->mat[i] * mat_source2->mat[i];
}


/* divide scalar source1 with scalar source2 to matrix destination
*/
void XXScalarScalarDiv (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = s1 / s2;
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}


/* take the negative value of the matrix source to the the matrix destination
*/
void XXMatrixInv (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;
	XXInteger i;

	d = mat_dest->mat;
	s = mat_source->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = -(*s);
		d++; s++; i--;
	}
}


/* take the transpose of the matrix source to the the matrix destination
*/
void XXMatrixTranspose (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;
	XXInteger i, j, rows, columns;

	d = mat_dest->mat;
	s = mat_source->mat;
	rows = mat_dest->rows;
	columns = mat_dest->columns;

	for(i = 0; i < rows; i++)
		for( j = 0; j < columns; j++)
			d[i * columns + j] = s[ j * rows + i];
}

%IF%%NUMBEROF_ELEMENTMUL%
/* multiply all elements element-wise to the destination
*/
void XXMatrixMulElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i;
	XXDouble *d, *s1, *s2;
	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	i = mat_source1->rows * mat_source1->columns;
	while(i)
	{
		*d = (*s1) * (*s2);
		d++; s1++; s2++; i--;
	}
}
%ENDIF%
%IF%%NUMBEROF_ELEMENTDIV%
/* divide all elements element-wise to the destination
*/
void XXMatrixDivElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i;
	XXDouble *d, *s1, *s2;
	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	i = mat_source1->rows * mat_source1->columns;
	while(i)
	{
		*d = (*s1) / (*s2);
		d++; s1++; s2++; i--;
	}
}
%ENDIF%
%IF%%NUMBEROF_ELEMENTPOWER%
/* pow all elements element-wise with the same scalar value to the destination
 * M = X .^ y
 */
void XXMatrixScalarPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble scalar_source2)
{
	XXInteger i;
	XXDouble *d, *s1;
	d = mat_dest->mat;
	s1 = mat_source1->mat;

	i = mat_source1->rows * mat_source1->columns;
	while(i)
	{
		*d = pow((*s1), scalar_source2);
		d++; s1++; i--;
	}
}

/* pow all elements element-wise to the destination
 * M = X .^ Y
 */
void XXMatrixPowElement (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i;
	XXDouble *d, *s1, *s2;
	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	i = mat_source1->rows * mat_source1->columns;
	while(i)
	{
		*d = pow((*s1),(*s2));
		d++; s1++; s2++; i--;
	}
}
%ENDIF%

/* use the source1 as an integer index for the destination
   and copy the scalar value of source2 at this point
*/
void XXMatrixMovRelAbs (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	/* source 1 is one based, we are zero based
	   leave some room for small variances. */
	XXInteger linIndex;

	linIndex = (XXInteger)(s1 - 0.9);

	mat_dest->mat[linIndex] = s2;
}


/* use the source2 as an integer index for the source1
   and copy this value of source1 to the scalar destination
*/
void XXMatrixMovAbsRel (XXDouble *dest, XXMatrix *mat_source1, XXDouble s2)
{
	/* source 2 is one based, we are zero based
	  leave some room for small variances. */
	XXInteger linIndex;

	linIndex = (XXInteger)(s2 - 0.9);

	*dest = mat_source1->mat[linIndex];
}

%IF%%NUMBEROF_MINFUNCTION%
/* find the minimum value in a matrix source and place this in
   the destination
*/
void XXMatrixMinimum (XXDouble *dest, XXMatrix *mat_source)
{
	XXDouble *s;
	XXInteger i;

	s = mat_source->mat;
	*dest = (*s);

	/* go to the second element */
	s++;

	i = mat_source->rows * mat_source->columns - 1;
	while(i)
	{
		if( (*s) < (*dest) )
			*dest = (*s);
		s++;
		i--;
	}
}
%ENDIF%
%IF%%NUMBEROF_MAXFUNCTION%
/* find the maximum value in a matrix source and place this in
   the destination
*/
void XXMatrixMaximum (XXDouble *dest, XXMatrix *mat_source)
{
	XXDouble *s;
	XXInteger i;

	s = mat_source->mat;
	*dest = (*s);

	/* go to the second element */
	s++;
	i = mat_source->rows * mat_source->columns - 1;

	while(i)
	{
		if( (*s) > (*dest) )
			*dest = (*s);
		s++;
		i--;
	}
}
%ENDIF%

/* summize all the elements of the matrix and put the result in the dest
*/
void XXMatrixSum (XXDouble *dest, XXMatrix *mat_source)
{
	XXDouble *s;
	XXInteger i;

	s = mat_source->mat;
	*dest = 0;
	i = mat_source->rows * mat_source->columns;

	while(i)
	{
		*dest += (*s);
		s++;
		i--;
	}
}


/* set the destination to the eye matrix
*/
void XXMatrixEye (XXMatrix *mat_dest)
{
	XXInteger i, size, rows, columns;
	XXDouble *d;

	rows = mat_dest->rows;
	columns = mat_dest->columns;
	size = rows * columns;
	d = mat_dest->mat;

	/* first set everything to zero */
	if( size > 0 )
		memset(d, 0, size * sizeof(XXDouble));

	for(i = 0; i < rows; i++)
		d[i*(columns+1)] = 1.0;
}


/* multiply the source1 n times with itself, with n in source2
   an integer number. The result is put in the destination,
   workarray must have at least the size of the destination matrix
   plus the workarray size of an inverse matrix operation
   this makes 4 * n * n + 2 * n with n = rows/columns of source/dest.
   source and destination should be square
*/
void XXMatrixPow (XXMatrix *mat_dest, XXMatrix *mat_source1,
		  XXDouble s2, XXDouble *workarray)
{
	XXDouble abssrc2;
	XXInteger i, pow_val, offset;
	XXMatrix workMatrix;

	abssrc2 = (XXDouble) fabs(s2);
	pow_val = (XXInteger)(abssrc2  + 0.1);

	/* map the work array on a local matrix */
	workMatrix.columns = mat_dest->columns;
	workMatrix.rows = mat_dest->rows;
	workMatrix.mat = workarray;

	/* first set the matrix to the eye value. */
	XXMatrixEye(mat_dest);

	/* keep multiplying the matrix with the source. */
	for( i = 0; i < pow_val; i++ )
	{
		/* multiply the source with the destination to the work matrix */
		XXMatrixMul(&workMatrix, mat_dest, mat_source1);

		/* and copy the workmatrix to the destination */
		XXMatrixMov(mat_dest, &workMatrix);
	}

	if( s2 < 0 )
	{
		/* take the inverse of the source if negative power */
		/* a work array is needed, but that was included in the
		   demand of this function */
		offset = workMatrix.columns * workMatrix.rows;

		/* the first part of the work array is the destination
		   the last part is work memory of the inverse */
		XXMatrixInverse(&workMatrix, mat_dest, &workarray[offset]);

		/* and copy the workmatrix to the destination */
		XXMatrixMov(mat_dest, &workMatrix);
	}
}


/* and the scalar scalar variant
*/
void XXScalarScalarPow (XXMatrix *mat_dest, XXDouble s1, XXDouble s2)
{
	XXDouble value;
	XXInteger i, size;

	value = (XXDouble) pow(s1, s2);
	size = mat_dest->rows * mat_dest->columns;
	for(i = 0; i < size; i++)
		mat_dest->mat[i] = value;
}

%IF%%NUMBEROF_CROSSFUNCTION%
/* take the cross product of matrix source1 and matrix source2
   to a destination matrix. all matrices must be 3x1
*/
void XXMatrixCrossProduct (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d, *s1, *s2;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* just do it */
	(*d) = s1[1] * s2[2] - s1[2] * s2[1]; d++;
	(*d) = s1[2] * s2[0] - s1[0] * s2[2]; d++;
	(*d) = s1[0] * s2[1] - s1[1] * s2[0];
}
%ENDIF%
%IF%%NUMBEROF_INNERFUNCTION%
/* take the inner product of matrix source1 and matrix source2
   to a scalar destination. the source matrices must be nx1
*/
void XXMatrixInnerProduct (XXDouble *dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXInteger i;
	XXDouble *s1, *s2;

	i = mat_source1->rows;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	*dest = 0.0;
	while(i)
	{
		*dest += (*s1) * (*s2);
		s1++;s2++;
		i--;
	}
}
%ENDIF%
%IF%%NUMBEROF_NORMFUNCTION%
/* take the 2-norm of matrix source to a scalar destination
*/
void XXMatrixNorm (XXDouble *dest, XXMatrix *mat_source)
{
	/* the implementation as on page 195 of Numerical Methods. */
	XXDouble *s;
	XXInteger i;
	XXDouble t;

	s = mat_source->mat;
	i = mat_source->rows * mat_source->columns;
	t = 0.0;

	while(i)
	{
		t += (*s) * (*s);
		s++;
		i--;
	}

	/* and take the square root of the result */
	*dest = sqrt(t);
}
%ENDIF%
%IF%%NUMBEROF_NORMINFFUNCTION%
/* take the inf norm of matrix source to a scalar destination
*/
void XXMatrixNormInf (XXDouble *dest, XXMatrix *mat_source)
{
	/* the implementation as on page 195/196 of Numerical Methods. */
	XXDouble p;
	XXDouble *s;
	XXInteger i, j, rows, columns;

	s = mat_source->mat;
	rows = mat_source->rows;
	columns = mat_source->columns;

	*dest = 0.0;
	for( i = 0; i < rows; i++ )
	{
		p = 0;
		for( j = 0; j < columns; j++ )
			p += fabs(s[i*columns+j]);
		if( p > (*dest) )
			*dest = p;
	}
}
%ENDIF%
%IF%%NUMBEROF_TRACEFUNCTION%
/* take the Trace of the matrix source to the scalar destination.
   The trace is defined as the sum of the diagonal values
*/
XXDouble XXMatrixTrace (XXMatrix *mat_source)
{
	XXDouble *s;
	XXDouble dest;
	XXInteger i, rows, columns;

	s = mat_source->mat;
	i = 0;
	rows = mat_source->rows;
	columns = mat_source->columns;

	dest = 0.0;
	while( i < rows && i < columns )
	{
		dest += s[i*(columns+1)];
		i++;
	}
	return dest;
}
%ENDIF%
%IF%%NUMBEROF_SYMMETRICFUNCTION%
/* take the symetric value of the source matrix.
   the result is placed in the destination matrix.
   the work array must have the same size as the source
*/
void XXMatrixSym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
{
	/* and a work matrix */
	XXMatrix workMatrix;

	/* map the work array on a local matrix */
	workMatrix.columns = mat_dest->columns;
	workMatrix.rows = mat_dest->rows;
	workMatrix.mat = workarray;

	/* first transpose the source to the destination */
	XXMatrixTranspose(mat_dest, mat_source);

	/* add those two matrices to the work array */
	XXMatrixAdd(&workMatrix, mat_dest, mat_source);

	/* and divide by a scalar two */
	XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
}
%ENDIF%
%IF%%NUMBEROF_ANTISYMMETRICFUNCTION%
/* take the anti symetric value of the source matrix.
   the result is placed in the destination matrix.
   the work array must have the same size as the source
*/
void XXMatrixAsym (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
{
	/* and a work matrix */
	XXMatrix workMatrix;

	/* map the work array on a local matrix */
	workMatrix.columns = mat_dest->columns;
	workMatrix.rows = mat_dest->rows;
	workMatrix.mat = workarray;

	/* first transpose the source to the destination */
	XXMatrixTranspose(mat_dest, mat_source);

	/* subtrace those two matrices to the work array */
	XXMatrixSub(&workMatrix, mat_source, mat_dest);

	/* and divide by a scalar two */
	XXMatrixScalarDiv(mat_dest, &workMatrix, 2.0);
}
%ENDIF%
%IF%%NUMBEROF_SKEWFUNCTION%
/* take the skew of the source matrix to a matrix destination
   source = 3x1, destination is 3x3
*/
void XXMatrixSkew (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;

	d = mat_dest->mat;
	s = mat_source->mat;

	/* row one */
	(*d) = 0; d++;
	(*d) = -s[2]; d++;
	(*d) = s[1]; d++;

	/* row two */
	(*d) = s[2]; d++;
	(*d) = 0; d++;
	(*d) = -s[0]; d++;

	/* row three */
	(*d) = -s[1]; d++;
	(*d) = s[0]; d++;
	(*d) = 0; d++;
}
%ENDIF%
%IF%%NUMBEROF_HOMOGENEOUSFUNCTION%
/* take the skew of the source1 matrix and source2 matrix
   to a matrix destination.
   source1 is 3x3 and soure2 = 3x1, destination is 4x4
*/
void XXMatrixHomogeneous (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d, *s1, *s2;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* row one */
	(*d) = s1[0]; d++;
	(*d) = s1[1]; d++;
	(*d) = s1[2]; d++;
	(*d) = s2[0]; d++;

	/* row two */
	(*d) = s1[3]; d++;
	(*d) = s1[4]; d++;
	(*d) = s1[5]; d++;
	(*d) = s2[1]; d++;

	/* row three */
	(*d) = s1[6]; d++;
	(*d) = s1[7]; d++;
	(*d) = s1[8]; d++;
	(*d) = s2[2]; d++;

	/* row four */
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 1;
}
%ENDIF%
%IF%%NUMBEROF_INVERSEHOMOGENEOUSFUNCTION%
/* take the inverse of a sourceH matrix to a destination matrix
   the source is 4x4 and the destination matrix is 4x4
*/
void XXMatrixInverseH (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;

	d = mat_dest->mat;
	s = mat_source->mat;

	/* row one */
	d[0] = s[0];
	d[1] = s[4];
	d[2] = s[8];

	/* row two */
	d[4] = s[1];
	d[5] = s[5];
	d[6] = s[9];

	/* row three */
	d[8] = s[2];
	d[9] = s[6];
	d[10] = s[10];

	/* and the position */
	d[3] = -(d[0] * s[3] + d[1] * s[7] + d[2] * s[11] );
	d[7] = -(d[4] * s[3] + d[5] * s[7] + d[6] * s[11] );
	d[11] = -(d[8] * s[3] + d[9] * s[7] + d[10] * s[11] );

	/* row four */
	d[12] = 0;
	d[13] = 0;
	d[14] = 0;
	d[15] = 1;
}
%ENDIF%
%IF%%NUMBEROF_ADJOINTFUNCTION%
/* Create an Adjoint matrix.
   source matrix is 4x4, destination matrix is 6x6
*/
void XXMatrixAdjoint (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;

	d = mat_dest->mat;
	s = mat_source->mat;

	/* row one */
	(*d) = s[0]; d++;
	(*d) = s[1]; d++;
	(*d) = s[2]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row two */
	(*d) = s[4]; d++;
	(*d) = s[5]; d++;
	(*d) = s[6]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row three */
	(*d) = s[8]; d++;
	(*d) = s[9]; d++;
	(*d) = s[10]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row four */
	(*d) = -s[11] * s[4] + s[7] * s[8]; d++;
	(*d) = -s[11] * s[5] + s[7] * s[9]; d++;
	(*d) = -s[11] * s[6] + s[7] * s[10]; d++;
	(*d) = s[0]; d++;
	(*d) = s[1]; d++;
	(*d) = s[2]; d++;

	/* row five */
	(*d) = s[11] * s[0] - s[3] * s[8]; d++;
	(*d) = s[11] * s[1] - s[3] * s[9]; d++;
	(*d) = s[11] * s[2] - s[3] * s[10]; d++;
	(*d) = s[4]; d++;
	(*d) = s[5]; d++;
	(*d) = s[6]; d++;

	/* row six */
	(*d) = -s[7] * s[0] + s[3] * s[4]; d++;
	(*d) = -s[7] * s[1] + s[3] * s[5]; d++;
	(*d) = -s[7] * s[2] + s[3] * s[6]; d++;
	(*d) = s[8]; d++;
	(*d) = s[9]; d++;
	(*d) = s[10];
}


/* Create an Adjoint matrix from two source matrices
   source1 matrix is 3x3 (orientation),
   source2 matrix is 3x1 (position),
   destination matrix is 6x6
*/
void XXMatrixAdjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d, *s1, *s2;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* row one */
	(*d) = s1[0]; d++;
	(*d) = s1[1]; d++;
	(*d) = s1[2]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row two */
	(*d) = s1[3]; d++;
	(*d) = s1[4]; d++;
	(*d) = s1[5]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row three */
	(*d) = s1[6]; d++;
	(*d) = s1[7]; d++;
	(*d) = s1[8]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row four */
	(*d) = -s2[2] * s1[3] + s2[1] * s1[6]; d++;
	(*d) = -s2[2] * s1[4] + s2[1] * s1[7]; d++;
	(*d) = -s2[2] * s1[5] + s2[1] * s1[8]; d++;
	(*d) = s1[0]; d++;
	(*d) = s1[1]; d++;
	(*d) = s1[2]; d++;

	/* row five */
	(*d) = s2[2] * s1[0] - s2[0] * s1[6]; d++;
	(*d) = s2[2] * s1[1] - s2[0] * s1[7]; d++;
	(*d) = s2[2] * s1[2] - s2[0] * s1[8]; d++;
	(*d) = s1[3]; d++;
	(*d) = s1[4]; d++;
	(*d) = s1[5]; d++;

	/* row six */
	(*d) = -s2[1] * s1[0] + s2[0] * s1[3]; d++;
	(*d) = -s2[1] * s1[1] + s2[0] * s1[4]; d++;
	(*d) = -s2[1] * s1[2] + s2[0] * s1[5]; d++;
	(*d) = s1[6]; d++;
	(*d) = s1[7]; d++;
	(*d) = s1[8];
}


/* Create an Adjoint matrix from a source matrix
   source1 matrix is 6x1
   destination matrix is 6x6
*/
void XXMatrixadjoint (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;

	d = mat_dest->mat;
	s = mat_source->mat;

	/* row one */
	(*d) = 0; d++;
	(*d) = -s[2]; d++;
	(*d) = s[1]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row two */
	(*d) = s[2]; d++;
	(*d) = 0; d++;
	(*d) = -s[0]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row three */
	(*d) = -s[1]; d++;
	(*d) = s[0]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row four */
	(*d) = 0; d++;
	(*d) = -s[5]; d++;
	(*d) = s[4]; d++;
	(*d) = 0; d++;
	(*d) = -s[2]; d++;
	(*d) = s[1]; d++;

	/* row two */
	(*d) = s[5]; d++;
	(*d) = 0; d++;
	(*d) = -s[3]; d++;
	(*d) = s[2]; d++;
	(*d) = 0; d++;
	(*d) = -s[0]; d++;

	/* row three */
	(*d) = -s[4]; d++;
	(*d) = s[3]; d++;
	(*d) = 0; d++;
	(*d) = -s[1]; d++;
	(*d) = s[0]; d++;
	(*d) = 0;
}


/* Create an adjoint matrix from two source matrices
   source1 matrix is 3x1
   source2 matrix is 3x1
   destination matrix is 6x6
*/
void XXMatrixadjoint1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d, *s1, *s2;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* row one */
	(*d) = 0; d++;
	(*d) = -s1[2]; d++;
	(*d) = s1[1]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row two */
	(*d) = s1[2]; d++;
	(*d) = 0; d++;
	(*d) = -s1[0]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row three */
	(*d) = -s1[1]; d++;
	(*d) = s1[0]; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;

	/* row four */
	(*d) = 0; d++;
	(*d) = -s2[2]; d++;
	(*d) = s2[1]; d++;
	(*d) = 0; d++;
	(*d) = -s1[2]; d++;
	(*d) = s1[1]; d++;

	/* row two */
	(*d) = s2[2]; d++;
	(*d) = 0; d++;
	(*d) = -s2[0]; d++;
	(*d) = s1[2]; d++;
	(*d) = 0; d++;
	(*d) = -s1[0]; d++;

	/* row three */
	(*d) = -s2[1]; d++;
	(*d) = s2[0]; d++;
	(*d) = 0; d++;
	(*d) = -s1[1]; d++;
	(*d) = s1[0]; d++;
	(*d) = 0;
}
%ENDIF%
%IF%%NUMBEROF_TILDEFUNCTION%
/* calcalate the tilde matrix from a source matrix
   source1 matrix is 6x1
   destination matrix is 4x4
*/
void XXMatrixTilde (XXMatrix *mat_dest, XXMatrix *mat_source)
{
	XXDouble *d, *s;

	d = mat_dest->mat;
	s = mat_source->mat;

	/* row one */
	(*d) = 0; d++;
	(*d) = -s[2]; d++;
	(*d) = s[1]; d++;
	(*d) = s[3]; d++;

	/* row two */
	(*d) = s[2]; d++;
	(*d) = 0; d++;
	(*d) = -s[0]; d++;
	(*d) = s[4]; d++;

	/* row three */
	(*d) = -s[1]; d++;
	(*d) = s[0]; d++;
	(*d) = 0; d++;
	(*d) = s[5]; d++;

	/* row four */
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0;
}


/* calcalate the tilde matrix from two source matrices
   source1 matrix is 3x1
   source2 matrix is 3x1
   destination matrix is 4x4
*/
void XXMatrixTilde1 (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2)
{
	XXDouble *d, *s1, *s2;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	s2 = mat_source2->mat;

	/* row one */
	(*d) = 0; d++;
	(*d) = -s1[2]; d++;
	(*d) = s1[1]; d++;
	(*d) = s2[0]; d++;

	/* row two */
	(*d) = s1[2]; d++;
	(*d) = 0; d++;
	(*d) = -s1[0]; d++;
	(*d) = s2[1]; d++;

	/* row three */
	(*d) = -s1[1]; d++;
	(*d) = s1[0]; d++;
	(*d) = 0; d++;
	(*d) = s2[2]; d++;

	/* row four */
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0; d++;
	(*d) = 0;
}
%ENDIF%
%IF%%NUMBEROF_BACKDIVISION%
/* calculate the solution of A x = b towards x 
   inside 20-sim this is done with an advanced linear solver
   NOTE: current code generation uses the x=inverse(A)*b approach instead */
void XXLinearSolve (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXString method, XXInteger id, XXDouble *workarray)
{
	/* a work matrix */
	XXMatrix workMatrix;

	/* map the work array on a local matrix */
	workMatrix.columns = mat_source1->columns;
	workMatrix.rows = mat_source1->rows;
	workMatrix.mat = workarray;

	/* calculate the inverse */
	XXMatrixInverse (&workMatrix, mat_source1, workarray + (workMatrix.columns * workMatrix.rows));
	
	/* and multiply with b */
	XXMatrixMul (mat_dest, &workMatrix, mat_source2);
}
%ENDIF%
/* This function fills the vector with elements 0, 1, 2 .... rows  */
void XXIndex (XXMatrix *v)
{
	/* We dont know if it is horizontal or vertical */
	XXInteger i, size;

	if( v->rows > v->columns )
		size = v->rows;
	else
		size = v->columns;

	for(i = 0; i < size; i++)
		v->mat[i] = (XXDouble) i;
}


/* this function swaps the vector v elements according to the indices of p
 * the work array must be at least the size of v
 */
void XXPermute (XXMatrix *v, XXMatrix *p, XXDouble *workarray)
{
	/* we dont know if it is horizontal or vertical */
	XXInteger i, size;

	if( v->rows > v->columns )
		size = v->rows;
	else
		size = v->columns;

	for( i = 0; i < size; i++)
		workarray[i] = v->mat[(XXInteger)p->mat[i]];

	/* and copy the values back to the matrix v */
	memcpy(v->mat, workarray, size * sizeof(XXDouble));
}


/* solves the equations by forward substiting : Ly = b
 * and backward substiting : Ux = y
 */
void XXSubstitute (XXMatrix *dest, XXMatrix *v)
{
	XXDouble t, diag;
	XXInteger i, j, rows, columns;

	rows = dest->rows;
	columns = dest->columns;

	/* forward substitution.*/
	for( i = 0; i < rows; i++)
	{
		t = v->mat[i];
		for( j = 0; j < i; j++ )
			t -= dest->mat[i*columns+j] * v->mat[j];

		diag = dest->mat[i*columns+i];
		if( diag == 0.0 )
		{
			/* error */
			return;
		}
		t /= diag;
		v->mat[i] = t;
	}

	/* back substitution */
	for( i = rows-1 ; i >= 0; i-- )
	{
		t = v->mat[i];
		for( j = i+1 ; j < rows; j++)
			t -= dest->mat[i*columns+j] * v->mat[j];
		v->mat[i] = t;
	}
}


/* swap the row1-th row with the row2-th row */
void XXSwapRows (XXMatrix *dest, XXInteger row1, XXInteger row2)
{
	XXDouble temp;
	XXInteger i, columns;

	columns = dest->columns;

	for( i = 0; i < columns; i++)
	{
		temp = dest->mat[row1 * columns + i];
		dest->mat[row1 * columns + i] = dest->mat[row2 * columns + i];
		dest->mat[row2 * columns + i] = temp;
	}
}


/* this function pivots the matrix, that means that zero elements are
 * avoided from the the diagonal if possible.
 * it returns an integer which can be used to adjust the sign of the
 * determinant of the matrix. This sign changes when a swap is being performed
 */
XXInteger XXPivot (XXMatrix *dest, XXMatrix *p, XXInteger i)
{
	XXInteger j, k, rows, columns, sgn;
	XXDouble t, mki;

	rows = dest->rows;
	columns = dest->columns;

	j = i;
	sgn = 1;
	t = 0;

	for( k = i; k < rows; k++)
	{
		mki = (XXDouble) fabs(dest->mat[k*columns+i]);
		if( mki > t )
		{
			t = mki;
			j = k;
		}
	}

	if( j > i )
	{
		XXSwapRows(dest, i, j); /* swap matrix rows   */
		XXSwapRows(p, i, j);    /* swap indices       */
		sgn = -sgn;             /* change sign of det */
	}
	return sgn;
}


/* this function creates a L and U CMatrix in one matrix. */
XXDouble XXDecompose (XXMatrix *dest, XXMatrix *p)
{
	XXDouble det, piv, mult;
	XXInteger i, j, k, rows, columns, sgn;

	rows = dest->rows;
	columns = dest->columns;

	det = 1.0;
	for( i = 0; i < rows; i++)
	{
		sgn = XXPivot(dest, p, i);
		piv = dest->mat[i*columns+i];
		det *= sgn * piv;

		if( det == 0.0 )
		{
			/* no solution is possible for this matrix.
			 * so inform the caller by returning this determinant.
			 */
			return 0.0;
		}

		for( j = i+1 ; j < rows; j++)
			dest->mat[i*columns+j] /= piv;

		for( j = i+1 ; j < rows ; j++)
		{
			mult = dest->mat[j*columns+i];
			if( mult != 0.0 )
			{
				for( k = i+1 ; k < rows; k++)
					dest->mat[j*columns+k] -= mult * dest->mat[i*columns+k];
			}
		}

	}
	return det;
}


/* this function returns the determinant of the matrix.
 * workarray must be at least 2 * dest->rows long
 */
XXDouble XXCrout1 (XXMatrix *dest, XXMatrix *v, XXDouble *workarray)
{
	XXMatrix p;
	XXDouble det;
	XXDouble *permwork;

	p.rows = dest->rows;
	p.columns = 1;
	p.mat = workarray;
	XXIndex(&p);                    /* create p = [0,1,2, ...., rows]         */
	det = XXDecompose(dest, &p);    /* this changes destination matrix itself.*/

	/* if the determinant is zero there is no solution possible.
	 * so return this determinant so that the caller is informed about
	 * this fact.
	 */
	if( det == 0.0)
		return 0.0;

	/* use the offset in the workarray as work array for the permute operation */
	permwork = &workarray[p.rows];
	XXPermute(v, &p, permwork);     /* swap the vector v using the swap vector p */
	XXSubstitute(dest, v);
	return det;
}


/* this crout routine preserves the values of this.
 * and stores the  changed values of the crouted matrix
 * in CroutMat. On output the vector x contains the answer.
 * and y is preserved
 * workarray must be at least 2 * dest->rows long
 */
XXDouble XXCrout2 (XXMatrix *dest, XXMatrix *CroutMat,
			 XXMatrix *x, XXMatrix *y, XXDouble *workarray)
{
	/* preserve memory */
	XXMatrixMov(CroutMat, dest);
	XXMatrixMov(x, y);
	return XXCrout1(CroutMat, x, workarray);
}


/* the inverse function calculates the matrix inverse
 * and returns the determinant.
 * workarray size at least (3 * n * n + 2 * n)
 * with n is rows is columns from source (=equal to destination)
 */
XXDouble XXInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
{
	/* wrapper matrices for the workarray */
	XXMatrix newMatrix;
	XXMatrix p;
	XXMatrix t;
	XXMatrix tempV;
	XXInteger i, offset, rows, columns;
	XXDouble det;

	rows = mat_source->rows;
	columns = mat_source->columns;

	/* map the workarray onto the the matrix objects */
	newMatrix.rows = rows;
	newMatrix.columns = columns;
	newMatrix.mat = workarray;
	offset = rows * columns;

	p.rows = rows;
	p.columns = 1;
	p.mat = &workarray[offset];
	offset += rows;

	t.rows = rows;
	t.columns = columns;
	t.mat = &workarray[offset];
	offset += rows * columns;

	tempV.rows = 1;
	tempV.columns = columns;
	tempV.mat = &workarray[offset];
	offset += columns;

	/* and do the calculations */
	XXIndex(&p);
	XXMatrixEye(&t);

	/* make a copy of the source, since we are going to chenge this */
	XXMatrixMov(&newMatrix, mat_source);
	det = XXDecompose(&newMatrix, &p);
	if( det == 0.0 )
	{
		/* there is no inverse of the matrix */
		return 0.0;
	}

	/* treat col vectors as row vectors. */
	for( i = 0; i < rows; i++)
	{
		XXMatrixGetRow(&tempV, &t, i);

		/* workarray here size of v */
		XXPermute( &tempV, &p, &workarray[offset]);
		XXSubstitute(&newMatrix, &tempV );

		XXMatrixSetRow(&t, &tempV, i);
	}

	/* transpose to col vectors to our final destination */
	XXMatrixTranspose(mat_dest, &t);

	return det;
}

%IF%%NUMBEROF_DETFUNCTION%
/* take the determinant of the matrix source and put it in the scalar destination *
 * simply by reusing a lot of the inverse functionality
 * NOTE: can be improved */
XXDouble XXMatrixDeterminant (XXMatrix *mat_source, XXDouble *workarray)
{
	/* wrapper matrices for the workarray */
	XXMatrix newMatrix;
	XXMatrix p;
	XXInteger rows, columns;

	rows = mat_source->rows;
	columns = mat_source->columns;

	/* map the workarray onto the the matrix objects */
	newMatrix.rows = rows;
	newMatrix.columns = columns;
	newMatrix.mat = workarray;

	p.rows = rows;
	p.columns = 1;
	p.mat = &workarray[rows * columns];

	/* and do the calculations */
	XXIndex(&p);

	/* make a copy of the source, since we are going to chenge this */
	XXMatrixMov(&newMatrix, mat_source);

	/* and return the determinant */
	return XXDecompose(&newMatrix, &p);
}
%ENDIF%

/* take the inverse of a matrix source to a matrix destination
 * workarray size at least (3 * n * n + 2 * n)
 * with n is rows is columns from source (=equal to destination)
 */
void XXMatrixInverse (XXMatrix *mat_dest, XXMatrix *mat_source, XXDouble *workarray)
{
	//XXDouble det;
	//det = XXInverse(mat_dest, mat_source, workarray);
	XXInverse(mat_dest, mat_source, workarray);

	/* here you could do something with the det result */
}


/* divide matrix source1 with matrix source2 to matrix destination
 * workarray size at least (4 * n * n + 2 * n)
 * with n is rows is columns from source2
 */
void XXMatrixDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXMatrix *mat_source2, XXDouble *workarray)
{
	XXMatrix workMatrix;
	XXInteger offset;
	XXDouble det;

	workMatrix.rows = mat_source2->rows;
	workMatrix.columns = mat_source2->columns;
	workMatrix.mat = workarray;
	offset = workMatrix.rows * workMatrix.columns;

	/* take the inverse and put it in our workmatrix */
	det = XXInverse(&workMatrix, mat_source2, &workarray[offset]);

	if( det == 0.0 )
		return;

	/* multiply source 1 with the workMatrix(=inverse(source1)) */
	XXMatrixMul(mat_dest, mat_source1, &workMatrix);
}


/* divide matrix source1 with scalar source2 to matrix destination */
void XXMatrixScalarDiv (XXMatrix *mat_dest, XXMatrix *mat_source1, XXDouble s2)
{
	XXDouble *d, *s1;
	XXInteger i;

	d = mat_dest->mat;
	s1 = mat_source1->mat;
	i = mat_dest->rows * mat_dest->columns;

	while (i)
	{
		(*d) = (*s1) / s2;
		d++; s1++; i--;
	}
}

/* divide scalar source1 with matrix source2 to matrix destination
 * workarray size at least (3 * n * n + 2 * n)
 * with n is rows is columns from source2 (=equal to destination)
 */
void XXScalarMatrixDiv (XXMatrix *mat_dest, XXDouble s1, XXMatrix *mat_source2, XXDouble *workarray)
{
	XXDouble det;
	XXInteger i, size;
	det = XXInverse(mat_dest, mat_source2, workarray);

	/* here you could do something with the det result */
	if( det == 0.0 )
		return;

	/* and multiply by the scalar */
	size = mat_dest->rows * mat_dest->columns;
	for( i = 0; i < size; i++)
		mat_dest->mat[i] *= s1;
}
/* end matrix functions */
%ENDIF%

#if ARDUINO >= 100

#include "Arduino.h"
%IF%%NUMBEROF_DLL_Arduino%
void Arduino_Initialize()
{
}

%ENDIF%
%IF%%NUMBEROF_DLL_Arduino_SetPinOutput%
void Arduino_SetPinOutput(XXDouble *inarr, int inputs, XXDouble *outarr, int outputs, int major)
{
	pinMode((int)inarr[0], OUTPUT);
}

%ENDIF%
%IF%%NUMBEROF_DLL_Arduino_pinMode%
void Arduino_pinMode(XXDouble *inarr, int inputs, XXDouble *outarr, int outputs, int major)
{
	pinMode((int)inarr[0], (int)inarr[1]);
}

%ENDIF%
%IF%%NUMBEROF_DLL_Arduino_digitalRead%
void Arduino_digitalRead(XXDouble *inarr, int inputs, XXDouble *outarr, int outputs, int major)
{
	outarr[0] = (XXDouble) digitalRead((int)inarr[0]);
}

%ENDIF%
%IF%%NUMBEROF_DLL_Arduino_digitalWrite%
void Arduino_digitalWrite(XXDouble *inarr, int inputs, XXDouble *outarr, int outputs, int major)
{
	digitalWrite((int)inarr[0], ((inarr[1] > 0.0f) ? HIGH : LOW));
}

%ENDIF%
%IF%%NUMBEROF_DLL_Arduino_analogWrite%
void Arduino_analogWrite(XXDouble *inarr, int inputs, XXDouble *outarr, int outputs, int major)
{
	analogWrite((int)inarr[0], (int)(inarr[1] * 255.0f));
}

%ENDIF%

unsigned char xx_timer_counter = 0;
unsigned char xx_timer_overflow = 0;

#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || \
    defined(__AVR_ATmega32U4__) || defined(__AVR_ATmega16U4__) || \
    defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

/* AVR/Arduino support functions */
#include <avr/io.h>
#include <avr/interrupt.h>

void XXInitTiming()
{
	cli();//stop interrupts

	// set timer0 interrupt at model frequency
	TCCR0A = 0;// set entire TCCR0A register to 0
	TCCR0B = 0;// same for TCCR0B
	TCNT0  = 0;//initialize counter value to 0

	// OCR = (F_CPU * xx_step_size / prescaler) - 1
	// prescaler @ 64 => 16.000.000 / 64 = 250000
	//   range: 0..255 = 250kHz .. 976.5625 Hz
	//   1 kHz = 249
	// prescaler @ 256 => 16.000.000 / 256 = 62500
	//   range: 0..255 = 62500 Hz .. 244.14 Hz
	//   250 Hz = 249
	// prescaler @ 1024 => 16.000.000 / 1024 = 15625
	//   range: 0..255 = 15625 Hz .. 61.035 Hz
	//   100 Hz = 155
	int prescaler = 64;
	int ocrVal = (int)((F_CPU/64) * xx_step_size);

	while(ocrVal > 256)
	{
	prescaler = prescaler << 2;
	ocrVal = ocrVal >> 2; 
	}

	// set compare match register
	OCR0A = (ocrVal - 1);
	// turn on CTC mode (clear timer on compare)
	TCCR0A |= (1 << WGM01);

	switch(prescaler)
	{
		case 64:
			xx_timer_overflow = 0;
			// Set CS01 and CS00 bits for 64 prescaler
			TCCR0B |= (1 << CS01) | (1 << CS00);   
			break;
		case 256:
			xx_timer_overflow = 0;
			// Set CS01 and CS00 bits for 256 prescaler
			TCCR0B |= (1 << CS02);   
			break;
		case 1024:
			xx_timer_overflow = 0;
			// Set CS01 and CS00 bits for 1024 prescaler
			TCCR0B |= (1 << CS02) | (1 << CS00);   
			break;
		default:
			// frequency is too low to reach with the hardware prescaler
			xx_timer_overflow = prescaler >> 10; // divide by 1024;
			prescaler = 1024;
			// Set CS01 and CS00 bits for 1024 prescaler
			TCCR0B |= (1 << CS02) | (1 << CS00);   
		break;
	}

	// enable timer compare interrupt
	TIMSK0 |= (1 << OCIE0A);

	sei();//allow interrupts
#ifdef ARDUINO_TIMER_DEBUG
	pinMode(13, OUTPUT);      // sets the digital pin 13 as output for timer toggle
#endif /* ARDUINO_TIMER_DEBUG */
}

#ifdef ARDUINO_TIMER_DEBUG
static char toggle1 = 0;
#endif

//Timer0 overflow interrupt
ISR(TIMER0_COMPA_vect)
{
	xx_timer_counter++;
#ifdef ARDUINO_TIMER_DEBUG
	toggle1 = !toggle1;
	digitalWrite(13, toggle1);
#endif
}
#elif defined (__arm__) && defined (__SAM3X8E__) /* Arduino Due compatible */
/* The timer code for the Arduino Due is based on the DueTimer code
 * created by Ivan Seidel Gomes, March, 2013. (https://github.com/ivanseidel/DueTimer)
 */
static uint8_t bestClock(double frequency, uint32_t* retRC)
{
	/*
		Pick the best Clock
		Timer		Definition
		TIMER_CLOCK1	MCK /  2
		TIMER_CLOCK2	MCK /  8
		TIMER_CLOCK3	MCK / 32
		TIMER_CLOCK4	MCK /128
	*/
	const struct {
		uint8_t flag;
		uint8_t divisor;
	} clockConfig[] = {
		{ TC_CMR_TCCLKS_TIMER_CLOCK1,   2 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK2,   8 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK3,  32 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK4, 128 }
	};
	float ticks;
	float error;
	int clkId = 3;
	int bestClock = 3;
	float bestError = 9.999e99;
	do
	{
		ticks = (float) VARIANT_MCK / frequency / (float) clockConfig[clkId].divisor;
		error = clockConfig[clkId].divisor * abs(ticks - round(ticks));	// Error comparison needs scaling
		if (error < bestError)
		{
			bestClock = clkId;
			bestError = error;
		}
	} while (clkId-- > 0);
	ticks = (float) VARIANT_MCK / frequency / (float) clockConfig[bestClock].divisor;
	*retRC = (uint32_t) round(ticks);
	return clockConfig[bestClock].flag;
}

void XXInitTiming()
{
	// We use channel 2 from Timer/Counter 2 (TC2)
	uint32_t rc = 0;
	uint8_t clock;
	
	// Calculate the required frequency
	double frequency = 1.0 / xx_step_size;

	// Tell the Power Management Controller to disable 
	// the write protection of the (Timer/Counter) registers:
	pmc_set_writeprotect(false);

	// Enable clock for the timer
	pmc_enable_periph_clk(TC8_IRQn);

	// Find the best clock for the wanted frequency
	clock = bestClock(frequency, &rc);

	// Set up the Timer in waveform mode which creates a PWM
	// in UP mode with automatic trigger on RC Compare
	// and sets it up with the determined internal clock as clock input.
	TC_Configure(TC2, 2, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | clock);
	// Reset counter and fire interrupt when RC value is matched:
	TC_SetRC(TC2, 2, rc);
	// Enable the RC Compare Interrupt...
	TC2->TC_CHANNEL[2].TC_IER=TC_IER_CPCS;
	// ... and disable all others.
	TC2->TC_CHANNEL[2].TC_IDR=~TC_IER_CPCS;

#ifdef ARDUINO_TIMER_DEBUG
	pinMode(13, OUTPUT);      // sets the digital pin 13 as output for timer toggle
#endif /* ARDUINO_TIMER_DEBUG */
	
	// Enable the interrupt routine
	NVIC_ClearPendingIRQ(TC8_IRQn);
	NVIC_EnableIRQ(TC8_IRQn);
	
	// Start the timer
	TC_Start(TC2, 2);
}

//Timer8 interrupt handler
void TC8_Handler(void)
{
	TC_GetStatus(TC2, 2);
	xx_timer_counter++;
#ifdef ARDUINO_TIMER_DEBUG
	toggle1 = !toggle1;
	digitalWrite(13, toggle1);
#endif
}
#else
	#error Unknown board.
#endif /* AVR vs. ARM arduino */
#endif /* ARDUINO >= 100 */